{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 8,
			"minor" : 5,
			"revision" : 7,
			"architecture" : "x64",
			"modernui" : 1
		}
,
		"classnamespace" : "dsp.gen",
		"rect" : [ 40.0, 85.0, 1061.0, 595.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 12.0,
		"default_fontface" : 0,
		"default_fontname" : "Arial",
		"gridonopen" : 1,
		"gridsize" : [ 15.0, 15.0 ],
		"gridsnaponopen" : 1,
		"objectsnaponopen" : 1,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"lefttoolbarpinned" : 0,
		"toptoolbarpinned" : 0,
		"righttoolbarpinned" : 0,
		"bottomtoolbarpinned" : 0,
		"toolbars_unpinned_last_save" : 0,
		"tallnewobj" : 0,
		"boxanimatetime" : 200,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"style" : "",
		"subpatcher_template" : "",
		"assistshowspatchername" : 0,
		"boxes" : [ 			{
				"box" : 				{
					"id" : "obj-7",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 515.0, 662.0, 35.0, 22.0 ],
					"text" : "out 2"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-1",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 3.0, 4.0, 28.0, 22.0 ],
					"text" : "in 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-2",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 813.0, 4.0, 28.0, 22.0 ],
					"text" : "in 2"
				}

			}
, 			{
				"box" : 				{
					"code" : "\r\ntwopole_lp(input){\r\n\tHistory history_1(0);\r\n\tHistory history_2(0);\r\n\tHistory history_3(0);\r\n\tHistory history_4(0);\r\n\r\n\t//Param cutoff(440, max=20000, min=1);\r\n\tParam Q(0.5, max = 10, min = 0.000001);\r\n\tParam omega(1.57, max = 3.14159265, min = 0.000001); //omega is 2pi*cutoff/samplerate, so between 0 and pi\r\n\t//min_5 = max(cutoff, 0.00001);\r\n\tmin_6 = max(Q, 0.000001);\r\n\t//omega = ((min_5 * twopi)) / samplerate;\r\n\tsn = sin(omega);\r\n\tcs = cos(omega);\r\n\tone_over_Q = 1 / min_6;\r\n\talpha = ((sn * 0.5)) * one_over_Q;\r\n\tb0 = 1 / ((1 + alpha));\r\n\ta2 = ((((1 - cs)) * 0.5)) * b0;\r\n\ta1 = ((1 - cs)) * b0;\r\n\tb1 = ((-2 * cs)) * b0;\r\n\tb2 = ((1 - alpha)) * b0;\r\n\texpr_7 = a2;\r\n\texpr_8 = a1;\r\n\texpr_9 = a2;\r\n\texpr_10 = b1;\r\n\texpr_11 = b2;\r\n\tmul_12 = input * expr_7;\r\n\tmul_13 = history_3 * expr_8;\r\n\tmul_14 = history_2 * expr_9;\r\n\tmul_15 = history_1 * expr_11;\r\n\tmul_16 = history_4 * expr_10;\r\n\tsub_17 = ((((mul_14 + mul_13)) + mul_12)) - ((mul_16 + mul_15));\r\n\tgen_18 = sub_17;\r\n\thistory_1 = fixdenorm(history_4);\r\n\thistory_2 = fixdenorm(history_3);\r\n\thistory_3 = fixdenorm(input);\r\n\thistory_4 = fixdenorm(sub_17);\r\n \treturn gen_18;\r\n}\r\n\r\nonepole(input){\r\n\tHistory y0(0);\r\n\r\n\tParam cutoff(1000, max=20000, min=1);\r\n\r\n\tcoeff_a = clip(sin(abs(cutoff) * 2 * PI / samplerate), 0, 1);\r\n\tmix5 = mix(y0, input, coeff_a);\r\n\ty0 = fixdenorm(mix5);\r\n\treturn mix5;\r\n}\r\n\r\nData buff(65600);\r\nBuffer prm(\"voice_parameter_buffer\");\r\n\r\nHistory current_position(0);\r\nHistory next_position(0);\r\nHistory current_read(0);   //at bbd samplerate\r\nHistory current_write(0);\r\n\r\nHistory slowcounter(0);\r\nHistory rate,rinv,feedback(0),hpf(0),mix(1),transtime(0),prefilt(1),postfilt(1),compandratio(2),icompand(0.5),sat(1),asat(1),chorus(0),bitdepth(24),bits(0),stib;\r\nHistory length(0),ilength(0);\r\nHistory last_write(0),diag(0);\r\nHistory srm(1);\r\n\r\n\r\nParam voice_is(0, min=0,default=0,max=4096);\r\nParam voice_offset(0);\r\nParam tr(0);\r\n\r\nslowcounter-=1;\r\nif(slowcounter<0){\r\n\t//rate,feedback,tilt,mix,size,transtime,prefilt,postfilt,compandratio,sat,chorus\r\n\tslowcounter=vectorsize;\r\n\tsrm = samplerate / 48000;\r\n\tlength = 64*pow(2,floor(10.999*peek(prm,4+voice_offset,0)));\r\n\tilength = 1/length;\r\n\trate = peek(prm, voice_offset, 0,channels=1);\r\n\trate = pow(2,rate) - 0.999;\r\n\trate *= 4;\r\n\tfeedback = 2*peek(prm, 1+voice_offset,0) - 1;\r\n\thpf = 2 * peek(prm,2+voice_offset,0) - 1;\r\n\thpfs = (hpf>0) ? 1 : -1;\r\n\thpf = pow(2,abs(hpf)) - 1;\r\n\thpf *= hpfs;\r\n\tmix = peek(prm, 3+voice_offset,0);\r\n\ttranstime = 0.5 * peek(prm, 5+voice_offset,0);\r\n\tprefilt = (peek(prm, 6+voice_offset,0));\r\n\t\r\n\tpostfilt = (peek(prm, 7+voice_offset,0));\r\n\tpostfilt = pi*(postfilt*clip(rate,0.01,1)+1-postfilt)/srm;\r\n\tcompandratio = 1+3*peek(prm, 8+voice_offset,0);\r\n\ticompand = 1 / compandratio;\r\n\tsat = 2*peek(prm, 9+voice_offset,0);\r\n\tsat *= sat;\r\n\tasat = 1/sat;\r\n\tchorus = 0.05*peek(prm, 10+voice_offset,0);\r\n\tbitdepth = 24 - floor(23 * peek(prm, 11+voice_offset,0));\r\n\tbits = pow(2, bitdepth);\r\n\tstib = 1/max(1,bits);\r\n}\r\nws=0;\r\nstep = slide(rate,2048,2048) * (1+in2);\r\nif(chorus>0){\r\n\tstep *= 1 + (cycle(3.5-(voice_is*0.005)) + 0.3* cycle(6+(voice_is*0.007))) * chorus;\r\n}\r\nnext_position += step;\r\nnp_i = floor(next_position);\r\nnp_f = next_position - np_i;\r\n\r\ninp = in1;\r\n//inp = sin(clip(0.25*inp,-1.5,1.5));\r\nfb = feedback * current_read;\r\nif(hpf<0){\r\n\tfb -= onepole(fb, cutoff= hpf*-8000);\r\n//\tfb -= twopole_lp(fb, omega = abs(hpf*halfpi), Q=0.4);\r\n}\r\n//fb = sin(clip(0.25*fb,-1.5,1.5));\r\ninp += fb;\r\ninp += twopole_lp(noise(), omega = 0.01, Q=0.2) * 0.000000059604644775390625; //makes it analogue\r\n//inp = 2.5*asin(clip(inp,-1,1));\r\nif((prefilt > 0) && (step < 1)){\r\n\t//om = pi*(prefilt*clip(step,0.01,0.99)+1-prefilt);\r\n\tinp = twopole_lp(inp, omega = pi*(prefilt*clip(step,0.01,0.99)+1-prefilt),Q=0.6);\r\n\tinp = twopole_lp(inp, omega=pi*(prefilt*clip(step,0.01,0.99)+1-prefilt)*0.9,Q=0.5);\r\n}\r\ncurrent_write += inp * step; //this isn't quite right - if a written sample goes over the boundary into the next one then the overhang is carried over\r\n\t// you could do that at the write step below instead though\r\n\r\n//diag=0;\r\nif(np_i != current_position){\r\n\tcarryover = inp * np_f;// / abs(step);\r\n\tcurrent_write -= carryover;\r\n\t\r\n\tfill = abs(np_i - current_position);\r\n\r\n\tif(fill<=1) current_write -= step*transtime * inp; //input during clock transition is 'lost'\r\n\t\t\t// only bother with this when running slow clocks\r\n\t\t\t\r\n\tif(next_position>=length){ // this has to come after fill is calculated\r\n\t\tnext_position -= length;\r\n\t\tnp_i = floor(next_position);\r\n\t}\r\n\tnp_i2=0;\r\n\tnp_i2=np_i+1;\r\n\tif(np_i2>=length) np_i2-=length;\r\n\tcurrent_read = peek(buff, np_i, 0) * (1-np_f) + np_f*peek(buff, np_i2, 0);\r\n\t\r\n\tw = current_write;\r\n\t\r\n\tif(compandratio>1){\r\n\t\t//COMPRESSOR SIDE OF THE COMPANDER HERE\r\n\t\tlev = slide(abs(current_write),50*srm,3000*srm);\r\n\t\tlt = clip(lev-0.25,0,99);\r\n\t\ttarg = 0.25 + lt * icompand;\r\n\t\tgc = clip(targ/lev,0,1);\r\n\t\tw *= gc;\r\n\t\t//diag = gc;\r\n\t}\r\n\t\r\n\tif(sat>0){\r\n\t\tw *= sat;\r\n\t\tw = tanh(0.2 + 0.8 * w);   //\t1 - 1.25 * (1-w) = - 0.25 + 1.25 * w\r\n\t\tw = asat * (1.25 * sin(w) - 0.25);   //THIS IS AN ASYMMETRIC SAT FROM THE CURVES ON THE DATASHEET\r\n\t}\r\n\t\r\n\t// bit-reduce here\r\n\tif(bitdepth<24){\r\n\t\tw2 = w * bits;\r\n\t\tw2 =  floor(w2);\r\n\t\tw2 *= stib;\r\n\t\tw = slide(w2,step,step);\r\n\t}\r\n\t\r\n\tif(fill<=1){\r\n\t\tpoke(buff,current_write,current_position,0);\r\n\t}else{\r\n\t\tws = current_write / fill;\r\n\t\tcoeff = (ws - last_write) / abs(step);\r\n\t\tw = last_write;\r\n\t\t//current_write = in1;\r\n\t\tif(np_i>current_position){ //one for loop, as it hasn't wrapped\r\n\t\t\t//diag=0.1;\r\n\t\t\twhile(current_position<np_i){\r\n\t\t\t\tw += coeff;\r\n\t\t\t\tpoke(buff,w,current_position,0);\r\n\t\t\t\tcurrent_position+=1;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//diag=2;\r\n\t\t\twhile(current_position<length){\r\n\t\t\t\tw += coeff;\r\n\t\t\t\tpoke(buff,w,current_position,0);\r\n\t\t\t\tcurrent_position+=1;\r\n\t\t\t}\r\n\t\t\tcurrent_position=0;\r\n\t\t\twhile(current_position<np_i){\r\n\t\t\t\tw += coeff;\r\n\t\t\t\tpoke(buff,w,current_position,0);\t\t\t\t\t\t\r\n\t\t\t\tcurrent_position+=1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tlast_write = w;\r\n\tcurrent_position = np_i;\r\n\t//current_write = feedback * current_read + carryover;\r\n\tcurrent_write = carryover;\r\n}\r\n\r\nif(compandratio>1){\r\n\t//EXPANDER SIDE OF THE COMPANDER HERE ON CURRENT READ\r\n\tlev = slide(abs(current_read),500*srm,500*srm);\r\n\tlt = clip(lev-0.25,0,99);\r\n\ttarg = 0.25 + lt * compandratio;\r\n\tgc = targ/(lt+0.25);\r\n\tcurrent_read *= gc;\r\n\tcurrent_read = tanh(current_read);\r\n\tdiag = gc;\r\n}\r\nif(postfilt < pi){\r\n\tcurrent_read = twopole_lp(current_read, omega = postfilt, Q=0.5);\r\n}\r\nif(hpf>0){\r\n\t//current_read -= twopole_lp(current_read, omega = hpf*halfpi, Q=0.4);\r\n\tcurrent_read -= onepole(current_read, cutoff=hpf*8000);\r\n}\r\n\r\nou = 2*asin(sin(current_read)*sqrt(mix)*0.3+sin(clip(in1,-halfpi,halfpi))*sqrt(1-mix)*0.3);\r\n\r\nout1 = ou;\r\nout2 = diag;//current_position * ilength;//length;\r\n",
					"fontface" : 0,
					"fontname" : "<Monospaced>",
					"fontsize" : 12.0,
					"id" : "obj-3",
					"maxclass" : "codebox",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 3.0, 32.0, 790.0, 592.0 ]
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-4",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 50.0, 662.0, 35.0, 22.0 ],
					"text" : "out 1"
				}

			}
 ],
		"lines" : [ 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 0 ],
					"source" : [ "obj-1", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 1 ],
					"source" : [ "obj-2", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-4", 0 ],
					"source" : [ "obj-3", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-7", 0 ],
					"source" : [ "obj-3", 1 ]
				}

			}
 ]
	}

}
